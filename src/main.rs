/// Auto-generated by sea-orm
mod entities;

mod poster;
mod render;

use axum::{
    extract::{Form, Query, State},
    http::StatusCode,
};
use entities::{post, prelude::*};
use maud::{html, Markup};
use sea_orm::{entity::*, query::*};
use serde::Deserialize;

use crate::poster::Poster;

#[derive(Clone)]
struct AppState {
    db: sea_orm::DatabaseConnection,
}

/// Request body for the `/posts` route.
#[derive(Deserialize)]
struct MakePost {
    content: String,
    poster: String,
}

/// Query parameters for the `/posts` route.
#[derive(Deserialize)]
struct GetPosts {
    name: Option<String>,
    hash: Option<String>,
}

const DATABASE_URL: &str = "sqlite:./database.db?mode=rwc";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    use axum::routing::get;
    use migration::MigratorTrait;

    // == DATABASE ==
    let db = sea_orm::Database::connect(DATABASE_URL).await?;
    migration::Migrator::up(&db, None).await?;

    let state = AppState { db };

    // == ROUTES ==
    let post_routes = axum::Router::new()
        .route("/", get(get_posts).post(make_post))
        .route("/new", get(get_post_form));

    let app = axum::Router::new()
        .route("/", get(root))
        .nest("/posts", post_routes)
        .with_state(state);

    // == RUN ==
    axum::Server::bind(&"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await?;

    Ok(())
}

async fn root() -> Markup {
    render::layout(
        "clovers",
        html! {
            #post-form { (render::post_button()) }
            ul #posts
                hx-get="/posts"
                hx-select="#posts"
                hx-swap="outerHTML"
                hx-trigger="revealed"
            { }
        },
    )
}

async fn get_post_form() -> Markup {
    html! {
        form.post-form
            hx-disinherit="*"
            hx-post="/posts"
            hx-target="#post-form"
            hx-select="#post-form"
            hx-swap="outerHTML"
            hx-select-oob="#posts:afterbegin"
        {
            label {
                span { "Name (optional)" }
                input name="poster" placeholder="Anonymous" autocomplete="off";
            }
            label {
                span { "Content" }
                textarea rows="10" name="content" placeholder="What's on your mind?" { }
            }
            button { "Post" }
            a href="#"
                hx-get="/"
                hx-target="#post-form"
                hx-select="#post-form"
                hx-swap="outerHTML"
            {
                "Cancel"
            }
        }
    }
}

async fn get_posts(
    State(state): State<AppState>,
    Query(query): Query<GetPosts>,
) -> Result<Markup, StatusCode> {
    use base64ct::Encoding;

    let bytes = query
        .hash
        .as_deref()
        .map(base64ct::Base64UrlUnpadded::decode_vec)
        .transpose()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let posts = Post::find()
        .apply_if(query.name.as_ref(), |query, name| {
            query.filter(post::Column::Name.eq(name))
        })
        .apply_if(bytes, |query, bytes| {
            query.filter(post::Column::Hash.eq(bytes))
        })
        .order_by_desc(post::Column::Id)
        .all(&state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let rendered_posts = html! {
        @for post in &posts {
            li { (render::post(post)) }
        }
    };

    Ok(render::layout(
        "clovers :: posts",
        html! {
            @if let Some(name) = &query.name {
                span {
                    "Searching for posts by "
                    span.poster {
                        (name)
                        @if let Some(hash) = &query.hash {
                            span.tripcode { " #" (hash) }
                        }
                    }
                }
            }
            ul #posts {
                (rendered_posts)
            }
        },
    ))
}

async fn make_post(
    State(state): State<AppState>,
    Form(post): Form<MakePost>,
) -> Result<Markup, StatusCode> {
    if post.content.is_empty() {
        return Ok(html! {
            li { (render::post_button()) }
        });
    }

    let Poster { name, hash } = post.poster.parse().expect("Infallible");

    let post = post::ActiveModel {
        content: ActiveValue::Set(post.content),
        name: ActiveValue::Set(name),
        hash: ActiveValue::Set(hash),
        ..Default::default()
    };

    let post = Post::insert(post)
        .exec_with_returning(&state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let rendered_post = render::post(&post);

    Ok(html! {
        #post-form { (render::post_button()) }
        ul #posts {
            li.new-post { (rendered_post) }
        }
    })
}
